<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Plato Network – Body Avatar Interface</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: #fff;
  color: #000;
  font-family: system-ui, -apple-system;
}

#app {
  position: fixed;
  inset: 0;
  overflow: hidden;
}

video, canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* center axis */
#axis {
  position: absolute;
  left: 50%;
  top: 0;
  width: 1px;
  height: 100%;
  background: rgba(0,0,0,0.25);
  pointer-events: none;
}

/* controls */
#controls {
  position: absolute;
  right: 12px;
  bottom: 80px;
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.ctrl {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,0.4);
  background: rgba(255,255,255,0.85);
  font-size: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
}

.ctrl.active {
  background: #000;
  color: #fff;
}

#label {
  position: absolute;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  letter-spacing: 0.14em;
  opacity: 0.6;
}
</style>
</head>

<body>
<div id="app">
  <video id="video" autoplay muted playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="axis"></div>

  <div id="controls">
    <div class="ctrl" id="rec">REC</div>
    <div class="ctrl" id="inv">INV</div>
    <div class="ctrl" id="trc">TRC</div>
    <div class="ctrl" id="axs">AXS</div>
    <div class="ctrl" id="face">FACE</div>
    <div class="ctrl" id="rst">RST</div>
  </div>

  <div id="label">PLATO · BODY AVATAR NETWORK</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = innerWidth;
canvas.height = innerHeight;

let history = [];
let maxHistory = 120;
let recording = false;
let inverted = false;
let axisLocked = false;
let lockedX = null;

let faceMode = 0; // 0 off, 1 wire, 2 mask

const btn = id => document.getElementById(id);

btn("rec").onclick = ()=> {
  recording = !recording;
  btn("rec").classList.toggle("active", recording);
};

btn("inv").onclick = ()=> {
  inverted = !inverted;
  document.body.style.background = inverted ? "#000" : "#fff";
  btn("inv").classList.toggle("active", inverted);
};

btn("trc").onclick = ()=> {
  maxHistory = maxHistory===120 ? 300 : 120;
  btn("trc").classList.toggle("active");
};

btn("axs").onclick = ()=> {
  axisLocked = !axisLocked;
  lockedX = null;
  btn("axs").classList.toggle("active");
};

btn("face").onclick = ()=> {
  faceMode = (faceMode + 1) % 3;
  btn("face").classList.toggle("active", faceMode!==0);
};

btn("rst").onclick = ()=> {
  history = [];
};

function center(pts){
  let x=0,y=0;
  pts.forEach(p=>{x+=p.x;y+=p.y});
  return {x:x/pts.length,y:y/pts.length};
}

function angle(a,b){
  return Math.atan2(b.y-a.y,b.x-a.x);
}

/* Face */
let faceLandmarks = null;

const faceMesh = new FaceMesh({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
});

faceMesh.setOptions({
  maxNumFaces: 1,
  refineLandmarks: false,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});

faceMesh.onResults(r=>{
  faceLandmarks = r.multiFaceLandmarks?.[0] || null;
});

/* Pose */
const pose = new Pose({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`
});

pose.setOptions({
  modelComplexity: 1,
  smoothLandmarks: true,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});

pose.onResults(r=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(r.image,0,0,canvas.width,canvas.height);

  if(r.poseLandmarks){
    const ls = r.poseLandmarks[11];
    const rs = r.poseLandmarks[12];
    const lh = r.poseLandmarks[23];
    const rh = r.poseLandmarks[24];

    const shoulderAngle = angle(ls,rs);
    const hipAngle = angle(lh,rh);
    const parallelism = Math.abs(shoulderAngle - hipAngle);

    let c = center([ls,rs,lh,rh]);
    if(axisLocked){
      if(lockedX===null) lockedX = c.x;
      c.x = lockedX;
    }

    if(recording || history.length===0){
      history.push({c,parallelism});
      if(history.length>maxHistory) history.shift();
    }

    history.forEach((h,i)=>{
      const a = i/history.length;
      ctx.strokeStyle = inverted
        ? `rgba(255,255,255,${a})`
        : `rgba(0,0,0,${a})`;
      ctx.lineWidth = Math.max(0.5,3-h.parallelism*8);
      if(i>0){
        const p = history[i-1].c;
        ctx.beginPath();
        ctx.moveTo(p.x*canvas.width,p.y*canvas.height);
        ctx.lineTo(h.c.x*canvas.width,h.c.y*canvas.height);
        ctx.stroke();
      }
    });
  }

  /* Face Avatar */
  if(faceLandmarks && faceMode!==0){
    ctx.strokeStyle = inverted ? "#fff" : "#000";
    ctx.fillStyle = inverted ? "#000" : "#fff";

    if(faceMode===1){
      ctx.lineWidth = 0.5;
      faceLandmarks.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x*canvas.width,p.y*canvas.height,1,0,Math.PI*2);
        ctx.stroke();
      });
    }

    if(faceMode===2){
      ctx.beginPath();
      faceLandmarks.forEach((p,i)=>{
        const x=p.x*canvas.width, y=p.y*canvas.height;
        i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
      });
      ctx.closePath();
      ctx.globalAlpha = 0.85;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
});

const camera = new Camera(video,{
  onFrame: async()=>{
    await pose.send({image:video});
    await faceMesh.send({image:video});
  },
  width:720,
  height:1280
});

camera.start();
</script>
</body>
</html>
